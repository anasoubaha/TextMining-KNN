# -*- coding: utf-8 -*-
"""TextMining_Oubaha_Anas_DSE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h0aahFSHK-LrILqzLf_Qy18XNwn8Lblw
"""

#Question 1:
BE=[["El-Bakkali a remporté la médaille d'or","sport"],["l'arbitre donne le coup de sifflet du début du match","sport"],["Le cyclisme est un sport d'endurance","sport"],
    ["Les Jeux olympiques de Tokyo sont désormais terminés !","sport"],["le premier but était marqué par Hakimi","sport"],["le maroc a redressé son économie","économie"],
    ["la covid a touché l'économie marocaine","économie"],["plusieurs entreprises sont en faillite","économie"],["la bourse a accéléré ses pertes à la fermeture","économie"],
    ["Bitcoin est la crypto-monnaie qui a la plus forte valorisation ","économie"],["les résultats des élections sont annonce par le ministère de l'Intérieur","politique"],
    ["le gouvernement envisage un nouveau confinement","politique"],["La politique étrangère du Maroc a changé","politique"],["le parlement a validé la loi 36.30","politique"],
    ["le gouvernement est parvenu à un accord","politique"]]

#Question 2:
#Création de la liste

def creatList(BE):
  L = []
  for i in range(len(BE)):
      for j in range(len(BE[i][0].split())):
          if not BE[i][0].split()[j] in L:
              
              L.append(BE[i][0].split()[j])
  return L

L = creatList(BE)

#Question 3:
#convertir texte en vect num
def t2v(t, L):
    VN = []
    T = t.split()
    for j in range(len(L)):
        cmpt = 0
        for i in range(len(T)):
            if T[i] == L[j]:
                cmpt = cmpt + 1
        VN.append(cmpt)
    return VN

#Conversion en BEnum
BEnum = []
for i in range(len(BE)):
    BEnum.append([t2v(BE[i][0], L), BE[i][1]])

#Question 4:
#Liste de Mots Vides 
MV = ['a','à','la','le','de','du','un','Le','La','est','Les','sont','!','?','par','son','en','ses','que','qui',"qu'on",'plus','les','des','toujours','dans']
#Creation de la liste reduite LR
LR = []
nbr1 = 0
nbr2 = 0
for i in range(len(BE)):
  for j in range(len(BE[i][0].split())):
    if not BE[i][0].split()[j] in LR:
      nbr1+=1
      if not BE[i][0].split()[j] in MV:
        nbr2+=1
        LR.append(BE[i][0].split()[j])

#Taux de  réduction
print("Taux de  réduction :",100 - nbr2*100/nbr1, "%")

#Question 5:
#definition de la fonction ELIM

def ELIM(L, BE):
  BS = [] #base de sport
  BEco = [] #base d'economie
  BP = [] #base de politique
  for i in range(len(BE)):
    for j in range(len(BE[i][0].split())):
          if BE[i][1] == "sport":
              BS.append(BE[i][0].split()[j])
          elif BE[i][1] == "économie":
              BEco.append(BE[i][0].split()[j])
          elif BE[i][1] == "politique":
              BP.append(BE[i][0].split()[j])
          else:
              break

  
  for k in range(len(L)):
    if L[k] in BS and L[k] in BEco and L[k] in BP:
      del L[k]
  
  return L

#Taux de  réduction
LE = ELIM(LR,BE) #appliquer sur la liste LR qui est sans stopwords
print("Taux de  réduction :",100 - len(LE)*100/len(L), "%")

#Question 6
#définir la distance euclidienne
from math import sqrt

def DIST(X,Y):
    d=0
    for i in range(len(X)):
        d=d+(X[i]-Y[i])**2        
    return sqrt(d)

#definition de K-NN 
def knn(k,t,b):

  #créer la table des distances t-b
  tD=[]
  for i in range(len(b)):
        tD.append([DIST(t,b[i][0]),b[i][1]])
  #trier la tD
  for i in range(len(tD)-1):
      for j in range(i):
            if tD[i][0]>tD[j][0]:
                temp=tD[i]
                tD[i]=tD[j]
                tD[j]=temp
  print(tD)
  #créer les tables tC et tO
  tC=[]
  tO=[]
  for i in range(len(BEnum)):
      if not BEnum[i][1] in tC:
            tC.append(BEnum[i][1])
            tO.append(0)
  #remplir la table tO
  for i in range(k):
      for j in range(len(tC)):
          if tD[i][1]==tC[j]:
              tO[j]=tO[j]+1
  print(tO)
  #retourner la classe prédite
  indmax=tO.index(max(tO))
  return tC[indmax]

#Question 7 (t2v):
#Prediction d'un text d'economie TE
TE = ["l'économie d'aujourd'hui a fait que les entreprises géants gagnent toujours !"]

#conversion avec t2v:
TEnum = t2v(TE[0], LE)

#application du modele KNN
#knn(1,TEnum,BEnum)
knn(3,TEnum,BEnum)

#Question 8 (t2v + MV + ELIM):
#Prediction d'un text de sport TS
TS = ["le lance de disque est un sport qu'on trouve dans les Jeux olympiques"]

#elimination des mots vides
TS2 =[]
for i in range(len(TS[0].split())):
  if not TS[0].split()[i] in MV:
      TS2.append(TS[0].split()[i])
TS2



#appel a la fonction ELIM sur la liste LR qui est sans stopwords
TS3 = ELIM(TS2,BE) 

#conversion avec t2v:
TSnum = t2v(TS3[0], LE) #LE est la liste sans stopwords et avec ELIM


#application du modele KNN
knn(1,TSnum,BEnum)

#Question 9 (t2v contre t2v + MV + ELIM):

TEA = ["l'économie d'aujourd'hui a fait que les entreprises géants gagnent toujours !"]

#le modele ne donne pas un bon resultat pour ce text avec t2v seulement, essayon d'appliquer MV et ELIM pour voir si on aura un meilleur resultat !

#elimination des mots vides
TEA2 =[]
for i in range(len(TE[0].split())):
  if not TE[0].split()[i] in MV:
      TE2.append(TE[0].split()[i])
TEA2



#appel a la fonction ELIM sur la liste LR qui est sans stopwords
TEA3 = ELIM(TE2,BE)

#conversion avec t2v:
TEAnum = t2v(TEA3[0], LE)

#application du modele KNN
knn(1,TEAnum,BEnum)

#Question 10:
#Le modèle d’apprentissage artificiel utilisé dans les questions 7 à 9 est un k-NN
#Ce genre de modèle a des avantages et des inconvénients.
#Parmi ces avantages c'est qu'il est le plus facile a comprendre et implementer des modeles d'apprentissage artificiel.
#L'inconvénient majeur de k-NN c'est qu'il est sensible aux attributs non pertinents d'où la nécessité d'introduire 
#d'autres méthodes tels que le stemming et la  lemmatisation.